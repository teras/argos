/*
 * SPDX-License-Identifier: Apache-2.0
 * SPDX-FileCopyrightText: 2025 Argos
 */

package onl.ycode.argos.completion

import onl.ycode.argos.snapshot.Snapshot

/**
 * Generates Fish shell completion scripts.
 *
 * This generator creates completion scripts compatible with the Fish shell (version 3.0+).
 * The generated script provides intelligent tab completion for:
 * - Long and short options with descriptions
 * - Domain/subcommand names with descriptions
 * - Option values (when applicable)
 * - Context-aware suggestions based on conditions
 *
 * Usage:
 * ```fish
 * # Source the generated completion script
 * myapp --completion fish | source
 *
 * # Or save it to a file
 * myapp --completion fish > ~/.config/fish/completions/myapp.fish
 * ```
 */
class FishCompletionGenerator : CompletionGenerator {
    override fun generate(snapshot: Snapshot): String {
        val appName = snapshot.settings.appName
        val options = snapshot.options.filter { !it.hidden }
        val domains = snapshot.domains

        return buildString {
            appendLine("# Fish completion script for $appName")
            appendLine("# Generated by Argos completion generator")
            appendLine()

            // Domain/subcommand completions
            if (domains.isNotEmpty()) {
                appendLine("# Subcommand completions")
                domains.forEach { domain ->
                    val desc = domain.label ?: domain.description ?: ""
                    val escapedDesc = desc.replace("'", "\\'")
                    appendLine("complete -c $appName -n '__fish_use_subcommand' -a '${domain.id}' -d '$escapedDesc'")

                    // Add aliases
                    domain.aliases.forEach { alias ->
                        appendLine("complete -c $appName -n '__fish_use_subcommand' -a '$alias' -d '$escapedDesc'")
                    }
                }
                appendLine()
            }

            // Option completions
            appendLine("# Option completions")
            options.forEach { spec ->
                val valueHint = spec.expectedDesc?.firstOrNull()?.let { " <$it>" } ?: ""
                val helpText = (spec.help ?: "").let { help ->
                    if (help.isEmpty()) valueHint.trim()
                    else if (valueHint.isNotEmpty()) "$help$valueHint"
                    else help
                }.replace("'", "\\'")

                val requiresArg = if (spec.requiresValue) " -r" else ""

                // Determine conditions for when this option should be suggested
                val declaredDomains = spec.declaredDomains
                val condition = if (domains.isNotEmpty()) {
                    if (declaredDomains == null) {
                        // Global option - available everywhere
                        ""
                    } else {
                        // Domain-specific option
                        val domainList = declaredDomains.joinToString(" ")
                        " -n '__fish_seen_subcommand_from $domainList'"
                    }
                } else {
                    ""
                }

                // Process each switch (short and long options)
                spec.switches.forEach { switch ->
                    when {
                        switch.startsWith("--") -> {
                            val optionName = switch.removePrefix("--")
                            append("complete -c $appName$condition -l '$optionName'$requiresArg")
                            if (helpText.isNotEmpty()) {
                                append(" -d '$helpText'")
                            }
                            appendLine()
                        }
                        switch.startsWith("-") && switch.length == 2 -> {
                            val shortName = switch.removePrefix("-")
                            append("complete -c $appName$condition -s '$shortName'$requiresArg")
                            if (helpText.isNotEmpty()) {
                                append(" -d '$helpText'")
                            }
                            appendLine()
                        }
                        else -> {
                            // Handle other prefix styles if needed
                            append("complete -c $appName$condition -a '$switch'$requiresArg")
                            if (helpText.isNotEmpty()) {
                                append(" -d '$helpText'")
                            }
                            appendLine()
                        }
                    }
                }
            }
        }
    }
}
