/*
 * SPDX-License-Identifier: Apache-2.0
 * SPDX-FileCopyrightText: 2025 Argos
 */

package onl.ycode.argos.completion

import onl.ycode.argos.snapshot.Snapshot

/**
 * Generates Zsh completion scripts.
 *
 * This generator creates completion scripts compatible with Zsh's completion system.
 * The generated script provides intelligent tab completion for:
 * - Long and short options with descriptions
 * - Domain/subcommand names with descriptions
 * - Option values (when applicable)
 * - Argument names and descriptions
 * - Context-aware suggestions
 *
 * Usage:
 * ```zsh
 * # Source the generated completion script
 * source <(myapp --completion zsh)
 *
 * # Or save it to a file in your fpath
 * myapp --completion zsh > ~/.zsh/completions/_myapp
 * # Add to .zshrc: fpath=(~/.zsh/completions $fpath)
 * ```
 */
class ZshCompletionGenerator : CompletionGenerator {
    override fun generate(snapshot: Snapshot): String {
        val appName = snapshot.settings.appName
        val options = snapshot.options.filter { !it.hidden }
        val domains = snapshot.domains

        return buildString {
            appendLine("#compdef $appName")
            appendLine("# Zsh completion script for $appName")
            appendLine("# Generated by Argos completion generator")
            appendLine()
            appendLine("_${appName}() {")
            appendLine("    local line state")
            appendLine()
            appendLine("    _arguments -C \\")

            // Generate option completions
            options.forEach { spec ->
                val helpText = spec.help?.replace("'", "\\'")?.replace("\"", "\\\"") ?: "No description"
                val valueHint = spec.expectedDesc?.firstOrNull() ?: "value"
                val argDesc = if (spec.requiresValue) ":$valueHint:" else ""

                if (spec.switches.size > 1) {
                    // Multiple switches - each needs to be quoted separately
                    spec.switches.forEach { switch ->
                        append("        ")
                        append("'$switch")
                        append("[")
                        append(helpText)
                        append("]")
                        append(argDesc)
                        append("'")
                        appendLine(" \\")
                    }
                } else {
                    // Single switch
                    append("        ")
                    val switch = spec.switches.first()
                    append("'$switch")
                    append("[")
                    append(helpText)
                    append("]")
                    append(argDesc)
                    append("'")
                    appendLine(" \\")
                }
            }

            // Domain/subcommand support
            if (domains.isNotEmpty()) {
                appendLine("        '1: :->cmds' \\")
                appendLine("        '*::arg:->args'")
                appendLine()
                appendLine("    case \$state in")
                appendLine("        cmds)")
                appendLine("            local -a subcommands")
                appendLine("            subcommands=(")
                domains.forEach { domain ->
                    val desc = domain.label ?: domain.description ?: "No description"
                    appendLine("                '${domain.id}:${desc.replace("'", "\\'")}'")
                }
                appendLine("            )")
                appendLine("            _describe 'command' subcommands")
                appendLine("            ;;")
                appendLine("        args)")
                appendLine("            # After subcommand, offer all options again")
                appendLine("            _arguments \\")
                // Generate options again for after subcommand
                options.forEach { spec ->
                    val helpText = spec.help?.replace("'", "\\'")?.replace("\"", "\\\"") ?: "No description"
                    val valueHint = spec.expectedDesc?.firstOrNull() ?: "value"
                    val argDesc = if (spec.requiresValue) ":$valueHint:" else ""

                    if (spec.switches.size > 1) {
                        spec.switches.forEach { switch ->
                            appendLine("                '$switch[$helpText]$argDesc' \\")
                        }
                    } else {
                        val switch = spec.switches.first()
                        appendLine("                '$switch[$helpText]$argDesc' \\")
                    }
                }
                // Remove trailing backslash
                setLength(length - 3)
                appendLine()
                appendLine("            ;;")
                appendLine("    esac")
            } else {
                // Remove trailing backslash from last line
                setLength(length - 3)
                appendLine()
            }

            appendLine("}")
            appendLine()
            appendLine("# Register the completion function")
            appendLine("compdef _$appName $appName")
        }
    }
}
