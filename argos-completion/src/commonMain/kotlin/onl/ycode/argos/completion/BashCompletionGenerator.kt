/*
 * SPDX-License-Identifier: Apache-2.0
 * SPDX-FileCopyrightText: 2025 Argos
 */

package onl.ycode.argos.completion

import onl.ycode.argos.snapshot.Snapshot

/**
 * Generates Bash completion scripts.
 *
 * This generator creates completion scripts compatible with bash-completion 2.x and later.
 * The generated script provides intelligent tab completion for:
 * - Long and short options with value hints
 * - Domain/subcommand names and aliases
 * - Option values (when applicable)
 * - Context-aware suggestions based on already-entered options
 *
 * Usage:
 * ```bash
 * # Source the generated completion script
 * source <(myapp --completion bash)
 *
 * # Or save it to a file
 * myapp --completion bash > /etc/bash_completion.d/myapp
 * ```
 */
class BashCompletionGenerator : CompletionGenerator {
    override fun generate(snapshot: Snapshot): String {
        val appName = snapshot.settings.appName
        val options = snapshot.options.filter { !it.hidden }
        val domains = snapshot.domains

        return buildString {
            appendLine("# Bash completion script for $appName")
            appendLine("# Generated by Argos completion generator")
            appendLine("# ")
            appendLine("# Options:")
            options.forEach { spec ->
                val switches = spec.switches.joinToString(", ")
                val valueHint = spec.expectedDesc?.firstOrNull()?.let { " <$it>" } ?: ""
                val helpText = spec.help ?: "No description"
                appendLine("#   $switches$valueHint - $helpText")
            }
            appendLine()
            appendLine("_${appName}_completion() {")
            appendLine("    local cur prev words cword")
            appendLine("    # Fallback for systems without bash-completion")
            appendLine("    if type _init_completion &>/dev/null; then")
            appendLine("        _init_completion || return")
            appendLine("    else")
            appendLine("        COMPREPLY=()")
            appendLine("        cur=\"\${COMP_WORDS[COMP_CWORD]}\"")
            appendLine("        prev=\"\${COMP_WORDS[COMP_CWORD-1]}\"")
            appendLine("        words=(\"\${COMP_WORDS[@]}\")")
            appendLine("        cword=\$COMP_CWORD")
            appendLine("    fi")
            appendLine()
            appendLine("    # All available options")
            append("    local opts=\"")
            options.flatMap { it.switches }.forEach { append("$it ") }
            appendLine("\"")
            appendLine()

            // Domain/subcommand completion
            if (domains.isNotEmpty()) {
                appendLine("    # Check if we're completing a subcommand")
                appendLine("    local subcommands=\"${domains.joinToString(" ") { it.id }}\"")
                appendLine()
                appendLine("    # If no subcommand selected yet, offer subcommands")
                appendLine("    for word in \"\${words[@]:1:\$cword}\"; do")
                appendLine("        if [[ \$subcommands =~ (^|[[:space:]])\$word(\$|[[:space:]]) ]]; then")
                appendLine("            # Subcommand found, complete options")
                appendLine("            COMPREPLY=( \$(compgen -W \"\$opts\" -- \"\$cur\") )")
                appendLine("            return 0")
                appendLine("        fi")
                appendLine("    done")
                appendLine()
                appendLine("    # No subcommand yet, suggest subcommands and global options")
                appendLine("    COMPREPLY=( \$(compgen -W \"\$subcommands \$opts\" -- \"\$cur\") )")
            } else {
                appendLine("    # Complete with available options")
                appendLine("    COMPREPLY=( \$(compgen -W \"\$opts\" -- \"\$cur\") )")
            }

            appendLine("    return 0")
            appendLine("}")
            appendLine()
            appendLine("# Register the completion function")
            appendLine("complete -F _${appName}_completion $appName")
        }
    }
}
